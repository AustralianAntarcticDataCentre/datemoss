#' Chronologies and growth rates of moss
#'
#' Provides facilities for estimating chronologies and growth rates
#' of moss (or similar) samples based on radiocarbon dating.
#'
#' @name DateMoss-package
#' @docType package
#' @author B. Raymond, S. Wotherspoon
NULL




##' Atmospheric radiocarbon calibration data
##'
##' Atmospheric radiocarbon data from 1450-2013.  These data are
##' largely based on Hua et al (2013), but have been extrapolated at
##' both ends.
##'
##' @name Atmospheric14C
##' @docType data
##' @title Atmospheric radiocarbon calibration data
##' @format A data frame with 6 columns and 163 rows.  The columns
##' represent
##' \tabular{rl}{
##' \code{Year} \tab Year of measurement. \cr
##' \code{F14C} \tab FIX ME. \cr
##' \code{F14C.sigma} \tab FIX ME. \cr
##' \code{D14C} \tab FIX ME. \cr
##' \code{F14C.sigma} \tab FIX ME. \cr
##' \code{PMC} \tab Percent modern carbon.
##' }
##' @source Hua, Q., Barbetti, M. & Rakowski, A. Z. (2013).
##' Atmospheric radiocarbon for the period 1950-2010.
##' Radiocarbon, 55(4), 2059-2072.
##' @keywords data
NULL



##' Initial Chronology for initializing MCMC sampler
##'
##' The function \code{generateInitial} generates random chronologies
##' that can be used to initialize the MCMC sampler
##' \code{\link{metropolisDate}}.
##'
##' The user must provide the vector \code{lengths} containing the
##' continuous sequence of segment lengths in timewise order, the
##' earliest possible date \code{tmin} and the final date \code{tmax}
##' (usually the acquisition date).  If in addition the user specifies
##' a maximal growth rate then cut dates will be generated such that the
##' growth rate never exceeds this upper limit, and if this is not
##' possible the function will raise an error.
##'
##' @title Initial Chronologies
##' @param lengths a vector of segment lengths (in timewise order)
##' @param tmin the minimum possible date
##' @param tmax the final date
##' @param chains the number of chains to generate initializations for
##' @param max.growth the maximum possible growth rate
##' @return a list of vectors of segment cut dates
##' @export
generateInitial <- function(lengths,tmin,tmax,chains=1L,max.growth=NULL) {
  n <- length(lengths)

  ## The minimum time interval for each segment
  dt.min <- if(!is.null(max.growth)) lengths/max.growth else rep(0,n)
  ## Residual, unaccounted for time
  r <- (tmax-tmin)-sum(dt.min)
  if(r < 0) stop("Max growth rate too low for time frame")

  ## Latest possible time for each cut
  ts.min <- tmax-rev(cumsum(c(0,rev(dt.min))))

  replicate(chains,ts.min - rev(c(0,sort(runif(n,0,r)))),simplify=FALSE)
}


##' Estimate segment times and growth rates by MCMC
##'
##' The user must supply the lengths \code{len} and mean carbon
##' concentrations \code{pmc} of the segments.  These must be supplied
##' in timewise order - oldest segment first and the segments must be
##' contiguous, but the concentration data may contain missing values.
##'
##' The user must also supply atmospheric radiocarbon calibration data
##' as two vectors, \code{Year} the time of measurement in
##' (fractional) years and \code{PMC} the recorded percentage of
##' modern carbon.
##'
##' The user may also supply a function that computes the
##' contributions of each segment to the log prior.  This function
##' takes two arguments, \code{ts} a vector of the (n+1) segment
##' endpoint times and \code{len} the lengths of the n segments.  This
##' function must compute the log of the (non-normalized) contributions
##' to prior from each segment.
##'
##' @title Estimate segment dates
##' @param ts.init a vector or a list of vectors of initial date
##' estimates, as generated by \code{generateInitial}
##' @param tmin the minimum possible date
##' @param len lengths of the segments (in timewise order, oldest
##' first)
##' @param pmc mean percentage modern carbon concentration of the
##' segments (in timewise order, oldest first)
##' @param Year calibration data - (fractional) year of atmospheric
##' carbon measurement
##' @param PMC calibration data - percent modern carbon
##' @param sigma standard deviation of PMC measurement errors (FIX
##' description)
##' @param iters number of samples to draw.
##' @param thin rate at which to thin samples.
##' @param chains number of chains to sample.
##' @param log.prior function to calculate the contribution from each
##' segment to the log prior for growth rates, given segment times and
##' lengths.
##' @param verbose report progress at prompt?
##' @return A coda object describing the segment times.
##' @importFrom coda mcmc mcmc.list
##' @export
metropolisDate <- function(ts.init,tmin,
                           len,pmc,Year,PMC,
                           sigma=4,iters=2000L,thin=25L,
                           chains=if(is.list(ts.init)) length(ts.init) else 1L,
                           log.prior=NULL,
                           verbose=interactive()) {

  ## Ensure ordering of calibration data
  PMC <- PMC[order(Year)]
  Year <- Year[order(Year)]

  ## Integrate calibration carbon concentrations by trapezoidal rule,
  ## and construct interpolator
  IPMC <- approxfun(Year,cumsum(c(0,diff(Year)*(PMC[-1L]+PMC[-length(PMC)])/2)))

  ## Given the segment end times, calculate the expected average PMC
  ## in each segment
  segmentPMC <- function(ts) diff(IPMC(ts))/diff(ts)


  ## Install uniform prior when none is given
  if(is.null(log.prior)) {
    log.prior <- function(ts,len) 0
  }

  ## Set up initial times
  ts.init <- rep(if(is.list(ts.init)) ts.init else list(ts.init),length.out=chains)
  n <- length(ts.init[[1L]])

  ## List of chains
  ch.times <- vector(mode="list",chains)

  ## PARALLEL - parallelize over this loop
  for(k1 in seq_len(chains)) {
    ## Allocate storage for this chain
    ch.ts <- matrix(0,iters,n)

    ## Initialize times for this chain
    ts <- as.vector(ts.init[[k1]])


    ## Output initial iteration count
    if(verbose) {
      cat("iter ",sprintf("%6d",1))
      flush.console()
    }

    for(k2 in seq_len(iters)) {

      ## Update iteration count
      if(verbose && k2%%100==0) {
        cat("\b\b\b\b\b\b");
        cat(sprintf("%6d",k2));
        flush.console()
      }

      for(k3 in seq_len(thin)) {

        ## Red-black update - update the times in two interleaved sets
        for(rb in seq_len(2L)) {

          ## Contribution to log posterior from each segment
          logps <- log.prior(ts,len)
          logps <- logps + ifelse(is.na(pmc),0,dnorm(pmc,segmentPMC(ts),sigma,log=T))

          ## Indices to update
          is <- seq.int(rb,n-1L,by=2L)

          ## New proposal
          lwr <- c(tmin,ts)[is]
          upr <- ts[is+1L]
          ts.new <- ts
          ts.new[is] <- runif(length(is),lwr,upr)

          ## Contribution to log posterior from each segment of proposal
          logps.new <- log.prior(ts.new,len)
          logps.new <- logps.new + ifelse(is.na(pmc),0,dnorm(pmc,segmentPMC(ts.new),sigma,log=T))

          ## Metropolis-Hastings rule - which proposals are kept?
          logp.is <- c(0,logps)[is]+logps[is]
          logp.is.new <- c(0,logps.new)[is]+logps.new[is]
          keep <- logp.is.new-logp.is > log(runif(length(is)))
          is <- is[keep]
          ts[is] <- ts.new[is]
        }
      }

      ## Store this sample
      ch.ts[k2,] <- ts
    }

    ## Store this chain's samples
    colnames(ch.ts) <- paste0("time",seq_len(n))
    ch.times[[k1]] <- ch.ts
    if(verbose) cat("\n")
  }

  ## Convert to a list of coda objects
  if(chains==1L) {
    mcmc(ch.times[[1L]],start=thin,thin=thin)
  } else {
    do.call(mcmc.list,lapply(ch.times,mcmc,start=thin,thin=thin))
  }
}


##' Estimate growth rates from the estimated segment times
##'
##' This function generates samples of segment growth rates from the
##' sample of segment cut dates generated by \code{metropolisDate}, and
##' the vector \code{lengths} of segment lengths in timewise order.
##'
##' @title Estimate Growth Rates
##' @param times a fitted object returned by \code{metropolisDate}
##' @param lengths a vector of segment lengths
##' @return a coda object describing the growth rates
##' @importFrom coda mcmc mcmc.list thin
##' @export
growthRate <- function(times,lengths) {

  coda <- function(tm) {
    tm <- as.array(tm)
    dt <- t(tm[,-1L]-tm[,-ncol(tm)])
    growth <- t(lengths/dt)
    colnames(growth) <- paste0("growth",seq_len(ncol(growth)))
    mcmc(growth,start=start(times),thin=thin(times))
  }

  if(inherits(times,"mcmc.list"))
    do.call(mcmc.list,lapply(times,coda))
  else
    coda(times)
}

##' Posterior prediction of segment mean carbon content
##'
##' Calculates the posterior segment mean carbon content given
##' atmospheric calibration data.
##'
##' @title Fitted Carbon Content
##' @param times a fitted object returned by \code{metropolisDate}
##' @param Year calibration data - (fractional) year of atmospheric
##' carbon measurement
##' @param PMC calibration data - recorded percentage of modern carbon
##' @return a coda object describing the growth rates
##' @importFrom coda mcmc mcmc.list thin
##' @export
carbonContent <- function(times,Year,PMC) {

  ## Integrate calibration carbon concentrations by trapezoidal rule,
  ## and construct interpolator
  PMC <- PMC[order(Year)]
  Year <- Year[order(Year)]
  IPMC <- approxfun(Year,cumsum(c(0,diff(Year)*(PMC[-1L]+PMC[-length(PMC)])/2)))

  ## Given the segment end times, calculate the expected average PMC
  ## in each segment
  segmentPMC <- function(ts) diff(IPMC(ts))/diff(ts)


  coda <- function(tm) {
    tm <- as.array(tm)
    pmc <- matrix(0,nrow(tm),ncol(tm)-1L)
    for(k in seq_len(nrow(tm))) pmc[k,] <- segmentPMC(tm[k,])
    colnames(pmc) <- paste0("PMC",seq_len(ncol(pmc)))
    mcmc(pmc,start=start(times),thin=thin(times))
  }

  if(inherits(times,"mcmc.list"))
    do.call(mcmc.list,lapply(times,coda))
  else
    coda(times)
}




##' Priors for growth rates.
##'
##' These functions construct functions to evaluate the contribution
##' to the log prior from each segment, for use with
##' \code{metropolisDate}.
##'
##' The \code{growth.prior.uniform} creates a uniform prior that
##' assumes growth rates are uniform up to a user specified maximum
##' rate.
##'
##' The \code{growth.prior.gamma} creates a Gamma prior for grwoth
##' rates.  The user can specify the either the parameters of the
##' distribution as either the prior mean and standard deviation or
##' the prior shape and rate of the Gamma distribution.
##'
##' @title Growth Priors
##' @param max.growth the maximum possible growth rate
##' @param mean the mean of the Gamma prior for growth
##' @param sd the standard deviation of the Gamma prior for growth
##' @param shape the shape parameter of the Gamma prior for growth
##' @param rate the rate parameter of the Gamma prior for growth
##' @return function to evaluate the contribution to the log prior
##' from each segment.
##' @export
growth.prior.uniform <- function(max.growth) {
  ## Return function to compute contributions to log prior
  function(ts,ls) {
    ## Compute growth rates
    gs <- ls/diff(ts)
    ## Growth rates above maximum are effectively impossible
    ifelse(gs < max.growth,0,-1.0E12)
  }
}

##' @rdname growth.prior.uniform
##' @export
growth.prior.gamma <- function(mean,sd,shape=(mean/sd)^2,rate=mean/sd^2) {
  ## Return function to compute contributions to log prior
  function(ts,ls) {
    ## Compute growth rates
    gs <- ls/diff(ts)
    ## Growth rates above maximum are effectively impossible
    dgamma(gs,shape=shape,rate=rate,log=TRUE)
  }
}



##' Quantiles from a coda object
##'
##' Converts an mcmc or mcmc.list object to a matrix and applies
##' quantile.
##'
##' @title Quantiles
##' @param x a coda object
##' @param ... further arguments passed to quantile
##' @return An array of quantiles
##' @importFrom stats quantile
##' @export
quantile.mcmc <- function(x,...) {
  t(apply(x,2,quantile,...))
}

##' @rdname quantile.mcmc
##' @export
quantile.mcmc.list <- function(x,...) {
  t(apply(do.call(rbind,x),2,quantile,...))
}

